## JVM Components

The Java Virtual Machine (JVM) is an integral part of the Java Runtime Environment that enables Java applications to be platform-independent. It works by interpreting bytecode into machine code. The JVM is divided into various components, each responsible for specific functions. This documentation explores the major JVM components in detail.

---

## 1. **Class Loader**

The *Class Loader* is responsible for dynamically loading Java classes into the JVM when they are required during runtime. It organizes how classes are loaded, verified, and initialized.

### **Subprocesses of Class Loader**
1. **Loading**  
   The loading phase refers to the process of locating class binaries and converting them into class objects. JVM uses different class loaders:
   - **Bootstrap Class Loader**  
     Responsible for loading essential classes (e.g., classes in Java's `rt.jar` like `java.lang.Object`).
   - **Extension Class Loader**  
     Loads classes located in the `jre/lib/ext` directory or specified by the `java.ext.dirs` system property.
   - **Application Class Loader**  
     Loads classes from the application's classpath (e.g. `.jar` files, user-defined classes).

2. **Linking**  
   The linking phase ensures that the loaded classes can interact with the JVM runtime by preparing the necessary data structures. This involves:
   - **Verification**  
     Ensures bytecode is correct and does not violate the JVM's safety rules (e.g., preventing buffer overflows, accessing private data, etc.).
   - **Preparation**  
     Allocates default memory for class variables and assigns default values (like `0` for integers or `null` for objects).
   - **Resolving**  
     Resolves references from symbolic references to actual memory locations.  
     - **Lazy Loading** (Optimization technique): Only loads and resolves classes when required.

3. **Initialization**  
   The JVM initializes static variables and executes static blocks in the class. This is when memory is allocated for variables, and constructors set initial values.

---

## 2. **JVM Memory**

The JVM manages memory in distinct spaces for efficient execution. This is divided into multiple areas to allow optimized handling of objects and program instructions.

### **JVM Memory Areas**
1. **Method Area**  
   - Stores metadata about loaded classes (e.g., name of the class, methods, fields).
   - In **Java 8+**, the method area is implemented as **Metaspace**, which dynamically grows or shrinks based on the class metadata it stores.
   - **Note**: Compiled code from the Just-In-Time (JIT) compiler is stored here in the form of native code.

2. **Heap**  
   The heap is where objects are stored (instances of classes are created here).
   - **On-Heap Memory**  
     - Managed by the Garbage Collector (GC). This is where most Java objects live.
   - **Off-Heap Memory**  
     - Used mostly for storing native (non-Java) code generated by the JIT compiler. Provides better performance since this memory is not managed by the GC.

3. **JVM Language Stack**  
   Each thread in a Java program has its own stack, storing method call frames.  
   - Each frame corresponds to a single method call.
   - It stores local variables and keeps a track of which *line of code* the thread is currently executing.

4. **PC Registers**  
   - Each thread in the JVM has its own PC (Program Counter) register.  
   - The PC register stores the **instruction currently being executed** by the thread at any moment.

5. **Native Method Stacks**  
   - Used by the JVM when executing native methods (methods written in C/C++ or other native languages).  
   - Stores information specific to native method execution.

### **Diagram for JVM Memory Areas**
```plaintext
|---------------- JVM MEMORY ----------------|
|                                            |
|   1. Method Area                           |
|      - MetaSpace                           |
|                                            |
|   2. Heap Memory                           |
|      - On-Heap                             |
|      - Off-Heap                            |
|                                            |
|   3. Java Stack (Thread-Level)             |
|      - Each thread has:                    |
|        - Method Call Frames                |
|                                            |
|   4. PC Registers                          |
|      - Tracks current instruction          |
|                                            |
|   5. Native Method Stack                   |
|      - Executes native methods             |
|                                            |
|--------------------------------------------|
```

---

## 3. **Execution Engine**

The *Execution Engine* is responsible for translating Java bytecode into machine code that can be executed by the underlying operating system.

### **Components of the Execution Engine**
1. **Interpreter**  
   - Reads and interprets bytecode line by line, converting it into machine code.
   - Slower compared to compiled machine code (due to line-by-line translation).

2. **JIT (Just-In-Time) Compiler**  
   To improve performance, the JIT Compiler converts entire methods or blocks of code (bytecode) into native machine code. Once converted, the native code can be executed directly.
   - **Intermediate Code Generator**  
     Converts bytecode to intermediate code representation.
   - **Code Optimizer**  
     Optimizes performance by eliminating redundant code, inlining methods, and other techniques.
   - **Target Code Generator**  
     Converts optimized intermediate code into native machine code specific to the platform.
   - **Profiler**  
     Monitors application performance and identifies frequently executed code ("hotspots") to optimize them further.

3. **Garbage Collector (GC)**  
   - Automatically manages memory by removing objects that are no longer reachable or usable.
   - Types of Garbage Collectors:
     - **Serial GC**: Best for single-threaded applications.
     - **Parallel GC**: Uses multiple threads for garbage collection.
     - **CMS (Concurrent Mark-Sweep) GC**: Reduces pause times by performing part of the garbage collection concurrently.
     - **G1 (Garbage-First) GC**: Combines parallel and concurrent collection techniques.

### **Execution Flow Diagram**
```plaintext
     Bytecode
         ↓
 (Execution Engine)
     → Interpreter
         ↓
      Native Code
         ↑
     → JIT Compiler
         ↑
  (Optimized Code Paths via Profiling)
```

---

## Missing & Additional Points

- **Garbage Collection in Heap:**  
   - The heap is divided into sections: **Young Generation**, **Old Generation**, and **Permanent Generation** (deprecated in Java 8). Garbage collection happens differently in each section.
   - **Young Generation**:  
     - Where new objects are allocated. Divided into `Eden` and `Survivor Spaces`. Minor GC occurs here.  
   - **Old Generation**:  
     - For long-lived objects. Major GC occurs here.  

- **Runtime Data Areas Specifics:**  
   - Thread-local allocation buffers (TLABs) exist within the heap for optimizing object allocations for individual threads.

---

## Final Overview Diagram
```plaintext
|-------------------------- JVM ---------------------------|
|                                                          |
|  1. Class Loader                                         |
|     - Loading                                            |
|     - Linking                                            |
|     - Initialization                                     |
|                                                          |
|  2. Memory Areas                                         |
|     - Method Area → MetaSpace                            |
|     - Heap Memory (On-Heap / Off-Heap)                   |
|     - JVM Stack → Local Variables, Call Frames           |
|     - PC Registers → Instruction Tracing                 |
|     - Native Method Stack                                |
|                                                          |
|  3. Execution Engine                                     |
|     - Interpreter → Executes Bytecode                    |
|     - JIT Compiler → Generates Native Machine Code       |
|          -> Code Optimizer / Profiler                    |
|     - Garbage Collector → Manages Memory                 |
|                                                          |
|----------------------------------------------------------|
```

This documentation should provide you a detailed understanding of how the JVM operates and how its components are interconnected. Identifying specific behaviors, like class loading and memory allocation, will also help you debug and write efficient Java applications.

---
Resources:

- [How JVM Works GFG](  https://www.geeksforgeeks.org/jvm-works-jvm-architecture/)



---