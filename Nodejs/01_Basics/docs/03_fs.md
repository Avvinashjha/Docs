##  `fs` (File System) Module

The `fs` module allows you to interact with the **file system** — read files, write data, create directories, and more.

> 🔗 Official Docs: [https://nodejs.org/api/fs.html](https://nodejs.org/api/fs.html)

### ✅ 3.1.1 Synchronous vs Asynchronous Methods

Node.js gives you **both sync and async** versions of file operations.

#### ❌ Synchronous (Blocking)
```js
const fs = require('fs');

// Blocks the entire process until file is read
const data = fs.readFileSync('data.txt', 'utf8');
console.log(data);

// Writes immediately — blocks until done
fs.writeFileSync('log.txt', 'App started');
```
- ✅ Simple to understand
- ❌ **Never use in production servers** — it **blocks** the event loop!

#### ✅ Asynchronous (Non-blocking) – Recommended
```js
const fs = require('fs');

// Reads file in background
fs.readFile('data.txt', 'utf8', (err, data) => {
  if (err) throw err;
  console.log(data);
});

// Writes without blocking
fs.writeFile('log.txt', 'User logged in', (err) => {
  if (err) console.error('Write failed:', err);
  else console.log('Log saved!');
});
```
- ✅ Doesn't block — perfect for servers
- Uses **callbacks** (error-first pattern)

> 💡 Use **Promises** for cleaner code:
```js
const fs = require('fs').promises;

async function readData() {
  try {
    const data = await fs.readFile('data.txt', 'utf8');
    console.log(data);
  } catch (err) {
    console.error('Error:', err);
  }
}
```

---

### ✅ 3.1.2 Reading and Writing Files

#### Reading a File
```js
fs.readFile('config.json', 'utf8', (err, data) => {
  if (err) {
    console.error('Could not read file:', err);
    return;
  }
  const config = JSON.parse(data);
  console.log('Port:', config.port);
});
```

#### Writing a File
```js
const user = { name: "Alice", active: true };
fs.writeFile('users.json', JSON.stringify(user, null, 2), (err) => {
  if (err) console.error('Save failed');
  else console.log('User saved!');
});
```

> 🛠 Real-World Use Case:  
Save app logs, cache configuration, or export data to JSON/CSV.

---

### ✅ 3.1.3 Working with Directories

```js
const fs = require('fs');

// Create directory
fs.mkdir('uploads', (err) => {
  if (err && err.code !== 'EEXIST') {
    console.error('Failed to create folder');
  }
});

// Read directory contents
fs.readdir('uploads', (err, files) => {
  if (err) return console.error(err);
  console.log('Files:', files);
});

// Remove directory (must be empty)
fs.rmdir('old-backup', (err) => {
  if (err) console.error('Delete failed');
});
```

> 🛠 Use Case:  
Auto-create `logs/`, `uploads/`, or `temp/` folders on app startup.

---

### ✅ 3.1.4 File Stats: `fs.stat()`

Check if a file is a file, directory, size, creation date, etc.

```js
fs.stat('data.txt', (err, stats) => {
  if (err) return console.error(err);

  console.log('Is file?', stats.isFile());        // true
  console.log('Is directory?', stats.isDirectory()); // false
  console.log('Size:', stats.size);               // 1024 bytes
  console.log('Created:', stats.birthtime);
});
```

> 🛠 Use Case:  
Validate uploads — reject if it's a folder or too large.

---

### ✅ 3.1.5 Streams: `fs.createReadStream()` & `fs.createWriteStream()`

For **large files**, don’t load everything into memory — **stream it in chunks**.

#### Example: Copy a Large Video File
```js
const fs = require('fs');

const readStream = fs.createReadStream('movie.mp4');
const writeStream = fs.createWriteStream('copy.mp4');

// Pipe data chunk by chunk
readStream.pipe(writeStream);

readStream.on('open', () => console.log('Reading started...'));
readStream.on('end', () => console.log('Copy complete!'));
```

> 🚀 Benefit: Uses minimal RAM — ideal for gigabyte-sized files.

---

### ✅ 3.1.6 File Paths: Using `path` Module with `fs`

File paths differ between OS (Windows: `\`, Unix: `/`). Use `path` to stay safe.

```js
const path = require('path');
const fs = require('fs');

// ✅ Safe path joining
const filePath = path.join('uploads', 'users', 'data.json');
// → Windows: uploads\users\data.json
// → Linux: uploads/users/data.json

fs.readFile(filePath, 'utf8', callback);
```

#### Other Useful `path` Methods
```js
console.log(path.extname('data.json'));     // '.json'
console.log(path.basename('/home/user/file.txt')); // 'file.txt'
console.log(path.dirname('/app/config.js')); // '/app'

// Convert to absolute path
console.log(path.resolve('logs/app.log')); // '/current/folder/logs/app.log'
```

> 🛠 Use Case:  
Build dynamic file paths in APIs (e.g., `/download/:filename`).

---

### ✅ 3.1.7 Error Handling in File Operations

Always handle errors — files may not exist, or permissions may be denied.

```js
fs.readFile('missing.txt', 'utf8', (err, data) => {
  if (err) {
    if (err.code === 'ENOENT') {
      console.error('File not found');
    } else if (err.code === 'EACCES') {
      console.error('Permission denied');
    } else {
      console.error('Unknown error:', err);
    }
    return;
  }
  console.log(data);
});
```

> 🔐 Pro Tip: Wrap in try-catch when using `fs.promises`.
